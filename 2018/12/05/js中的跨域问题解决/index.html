<!DOCTYPE html>
<html lang="zh-cn">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="哈哈哈嗝~">
  <meta name="author" content="Luking Xun">
  <meta name="keywords" content="噗哈哈哈">
  <title>js中的跨域及其解决的办法 ~ 永恒的金色年华</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
  
  <link rel="stylesheet" href="/css/main.css">

  
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>永恒的金色年华</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">主页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">档案</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类目录</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/无与伦比图片.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p class="mt-3">星期三, 十二月 5日 2018, 6:40 晚上</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <h1 id="js中的跨域及其解决的办法"><a href="#js中的跨域及其解决的办法" class="headerlink" title="js中的跨域及其解决的办法"></a>js中的跨域及其解决的办法</h1><h3 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h3><p>在了解跨域之前，首先要知道什么是同源策略（same-origin policy）。简单来讲同源策略就是浏览器为了保证用户信息的安全，防止恶意的网站窃取数据，禁止不同域之间的JS进行交互。对于浏览器而言只要域名、协议、端口其中一个不同就会引发同源策略，从而限制他们之间如下的交互行为：</p>
<p>1.Cookie、LocalStorage和IndexDB无法读取；</p>
<p>2.DOM无法获得；</p>
<p>3.AJAX请求不能发送。</p>
<p>跨域的严格一点的定义是：只要协议，域名，端口有任何一个的不同，就被当作是跨域。</p>
<p>如下表所示：    </p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许通信</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td>
<td>同一域名下</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/lab/a.js" target="_blank" rel="noopener">http://www.a.com/lab/a.js</a><br><a href="http://www.a.com/script/b.js" target="_blank" rel="noopener">http://www.a.com/script/b.js</a></td>
<td>同一域名下不同文件夹</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com:8000/a.js" target="_blank" rel="noopener">http://www.a.com:8000/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td>
<td>同一域名，不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a><br><a href="https://www.a.com/b.js" target="_blank" rel="noopener">https://www.a.com/b.js</a></td>
<td>同一域名，不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a><br><a href="http://70.32.92.74/b.js" target="_blank" rel="noopener">http://70.32.92.74/b.js</a></td>
<td>域名和域名对应ip</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a><br><a href="http://script.a.com/b.js" target="_blank" rel="noopener">http://script.a.com/b.js</a></td>
<td>主域相同，子域不同</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a><br><a href="http://a.com/b.js" target="_blank" rel="noopener">http://a.com/b.js</a></td>
<td>同一域名，不同二级域名（同上）</td>
<td>不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="noopener">http://www.cnblogs.com/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td>
<td>不同域名</td>
<td>不允许</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>特别注意两点：</p>
<p>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，</p>
<p>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</p>
<p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。</p>
<h3 id="二、为什么浏览器要限制跨域访问呢？"><a href="#二、为什么浏览器要限制跨域访问呢？" class="headerlink" title="二、为什么浏览器要限制跨域访问呢？"></a>二、为什么浏览器要限制跨域访问呢？</h3><p>原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题：</p>
<p>1.用户访问<a href="http://www.mybank.com，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器；" target="_blank" rel="noopener">www.mybank.com，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器；</a></p>
<p>2.用户突然想起件事，并迷迷糊糊的访问了一个邪恶的网站<a href="http://www.xiee.com；" target="_blank" rel="noopener">www.xiee.com；</a></p>
<p>3.这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对<a href="http://www.mybank.com的操作；" target="_blank" rel="noopener">www.mybank.com的操作；</a></p>
<p>4.如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。</p>
<h3 id="三、为什么要跨域？"><a href="#三、为什么要跨域？" class="headerlink" title="三、为什么要跨域？"></a>三、为什么要跨域？</h3><p>既然有安全问题，那为什么又要跨域呢？ 有时公司内部有多个不同的子域，比如一个是location.company.com ,而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域。</p>
<h3 id="四、解决跨域问题的方法："><a href="#四、解决跨域问题的方法：" class="headerlink" title="四、解决跨域问题的方法："></a>四、解决跨域问题的方法：</h3><h4 id="1-跨域资源共享（CORS）"><a href="#1-跨域资源共享（CORS）" class="headerlink" title="1.跨域资源共享（CORS）"></a>1.跨域资源共享（CORS）</h4><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<p>只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！</p>
<p>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定允许其他域名访问</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Origin:*'</span><span class="comment">//或指定域</span></span><br><span class="line"><span class="comment">//响应类型</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods:GET,POST'</span></span><br><span class="line"><span class="comment">//响应头设置</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers:x-requested-with,content-type'</span></span><br></pre></td></tr></table></figure>

<h4 id="2-通过jsonp跨域"><a href="#2-通过jsonp跨域" class="headerlink" title="2.通过jsonp跨域"></a>2.通过jsonp跨域</h4><p>JSONP是JSON with Padding（填充式json）的简写，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>,<span class="string">"trigkit4"</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>
<p><strong>JSONP的原理</strong>：通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用JavaScript动态加载一个script文件，同时定义一个callback函数给script执行而已。）</p>
<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://example.com/data.php，那么a.html中的代码就可以这样：" target="_blank" rel="noopener">http://example.com/data.php，那么a.html中的代码就可以这样：</a></p>
<script type="text/javascript">
    function dosomething(jsondata){
        //处理获得的json数据
    }
</script>
<script src="http://example.com/data.php?callback=dosomething"></script>
<p>js文件载入成功后会<strong>执行</strong>我们在url参数中<strong>指定的函数</strong>，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">callback = _GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></span><br><span class="line">data = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></span><br><span class="line"><span class="keyword">echo</span> callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p><img src="https://images2017.cnblogs.com/blog/1191190/201708/1191190-20170824154926855-473423436.png" srcset="/img/loading.gif" alt></p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<script type="text/javascript">
    $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){
        //处理获得的json数据
    });
</script>
<h5 id="JSONP的优缺点："><a href="#JSONP的优缺点：" class="headerlink" title="JSONP的优缺点："></a>JSONP的优缺点：</h5><p>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p>
<p>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p>
<h5 id="CORS和JSONP对比："><a href="#CORS和JSONP对比：" class="headerlink" title="CORS和JSONP对比："></a>CORS和JSONP对比：</h5><p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>
<p>（1）JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求；</p>
<p>（2）使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得说句，比起JSONP有更好的错误处理；</p>
<p>（3）JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS；</p>
<h4 id="3-通过修改document-domain来跨子域"><a href="#3-通过修改document-domain来跨子域" class="headerlink" title="3.通过修改document.domain来跨子域"></a>3.通过修改document.domain来跨子域</h4><p>上面的jsonp是来解决ajax跨域请求的，那么如果是需要处理 Cookie 和 iframe 该怎么办呢？这时候就可以通过修改document.domain来跨子域。两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie或者处理iframe。比如A网页是<a href="http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。" target="_blank" rel="noopener">http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span><br><span class="line"><span class="comment">//现在，A网页通过脚本设置一个 Cookie。</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"test1=hello"</span>;</span><br><span class="line"><span class="comment">//B网页就可以读到这个 Cookie。</span></span><br><span class="line"><span class="keyword">var</span> allCookie = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>

<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。<br>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key=value; domain=.example.com; path=<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</span></span><br></pre></td></tr></table></figure>

<p>不同的iframe 之间（父子或同辈），是能够获取到彼此的window对象的，但是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。<br>首先说明一下同域之间的iframe是可以操作的。比如<a href="http://127.0.0.1/JSONP/a.html里面嵌入一个iframe指向http://127.0.0.1/myPHP/b.html。那么在a.html里面是可以操作iframe里面的DOM的。" target="_blank" rel="noopener">http://127.0.0.1/JSONP/a.html里面嵌入一个iframe指向http://127.0.0.1/myPHP/b.html。那么在a.html里面是可以操作iframe里面的DOM的。</a></p>
<iframe src="http://127.0.0.1/myPHP/b.html" frameborder="1"></iframe>
<body>
<script type="text/javascript">
var iframe = document.querySelector("iframe");
iframe.onload = function(){
    var win = iframe.contentWindow;
    var doc = win.document;
    var ele = doc.querySelector(".text1");
    var text = ele.innerHTML="123456";
}
</script>
如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。如果两个窗口一级域名相同，只是二级域名不同，那么document.domain属性，就可以规避同源政策，拿到DOM。 

<h4 id="4-使用window-name来进行跨域"><a href="#4-使用window-name来进行跨域" class="headerlink" title="4.使用window.name来进行跨域"></a>4.使用window.name来进行跨域</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。<br>比如：有一个页面a.html,它里面有这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">"我是a页面设置的"</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.location = <span class="string">"http://127.0.0.1/JSONP/b.html"</span>;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h6 id="b-html页面的代码："><a href="#b-html页面的代码：" class="headerlink" title="b.html页面的代码："></a>b.html页面的代码：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h6 id="a-html页面载入后1秒，跳转到了b-html页面，结果b页面打印出了："><a href="#a-html页面载入后1秒，跳转到了b-html页面，结果b页面打印出了：" class="headerlink" title="a.html页面载入后1秒，跳转到了b.html页面，结果b页面打印出了："></a>a.html页面载入后1秒，跳转到了b.html页面，结果b页面打印出了：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是a页面设置的</span><br></pre></td></tr></table></figure>

<p>可以看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。<br>利用window.name可以对同域或者不同域的之间的js进行交互。<br>那么在a.html页面中，我们怎么把b.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来载入b.html页面，因为我们想要即使a.html页面不跳转也能得到b.html里的数据。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取b.html的数据，然后a.html再去得到iframe获取到的数据。</p>
<h4 id="5-使用HTML5的window-postMessage方法跨域"><a href="#5-使用HTML5的window-postMessage方法跨域" class="headerlink" title="5.使用HTML5的window.postMessage方法跨域"></a>5.使用HTML5的window.postMessage方法跨域</h4><p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。<br>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>举例来说，父窗口<a href="http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。" target="_blank" rel="noopener">http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。</a><br>a页面：</p>
<iframe id="frame1" src="http://127.0.0.1/JSONP/b.html" frameborder="1"></iframe>document.getElementById('frame1').onload = function(){
    var win = document.getElementById('frame1').contentWindow;
    win.postMessage("我是来自a页面的","http://127.0.0.1/JSONP/b.html")
}


<p>b页面通过监听message事件可以接受到来自a页面的消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || event;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);<span class="comment">//我是来自a页面的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子窗口向父窗口发送消息的写法类似。</p>
<p>window.opener.postMessage(‘我是来自b页面的’, ‘<a href="http://a.com&#39;" target="_blank" rel="noopener">http://a.com&#39;</a>);<br>//父窗口和子窗口都可以通过message事件，监听对方的消息。<br>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。<br>下面是一个例子，主窗口写入iframe子窗口的localStorage。<br>父窗口发送消息代码：</p>
<p>var win = document.getElementsByTagName(‘iframe’)[0].contentWindow;<br>var obj = { name: ‘Jack’ };<br>// 存入对象<br>win.postMessage(JSON.stringify({key: ‘storage’, method: ‘set’, data: obj}), ‘<a href="http://b.com&#39;" target="_blank" rel="noopener">http://b.com&#39;</a>);<br>// 读取对象<br>win.postMessage(JSON.stringify({key: ‘storage’, method: “get”}), “*”);<br>window.onmessage = function(e) {<br>  if (e.origin != ‘<a href="http://a.com&#39;" target="_blank" rel="noopener">http://a.com&#39;</a>) return;<br>  // “Jack”<br>  console.log(JSON.parse(e.data).name);<br>};<br>子窗口接收消息的代码：</p>
<p>window.onmessage = function(e) {<br>  if (e.origin !== ‘<a href="http://bbb.com&#39;" target="_blank" rel="noopener">http://bbb.com&#39;</a>) return;<br>  var payload = JSON.parse(e.data);<br>  switch (payload.method) {<br>    case ‘set’:<br>      localStorage.setItem(payload.key, JSON.stringify(payload.data));<br>      break;<br>    case ‘get’:<br>      var parent = window.parent;<br>      var data = localStorage.getItem(payload.key);<br>      parent.postMessage(data, ‘<a href="http://aaa.com&#39;" target="_blank" rel="noopener">http://aaa.com&#39;</a>);<br>      break;<br>    case ‘remove’:<br>      localStorage.removeItem(payload.key);<br>      break;<br>  }<br>};</p>
<h4 id="6-通过WebSocket进行跨域"><a href="#6-通过WebSocket进行跨域" class="headerlink" title="6.通过WebSocket进行跨域"></a>6.通过WebSocket进行跨域</h4><p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p>
<p>web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p>
<p>只有在支持web socket协议的服务器上才能正常工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSockt(<span class="string">'ws://www.baidu.com'</span>);<span class="comment">//http-&gt;ws; https-&gt;wss</span></span><br><span class="line">socket.send(<span class="string">'hello WebSockt'</span>);</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-图像ping（单向）"><a href="#7-图像ping（单向）" class="headerlink" title="7.图像ping（单向）"></a>7.图像ping（单向）</h4><h5 id="什么是图像ping："><a href="#什么是图像ping：" class="headerlink" title="什么是图像ping："></a>什么是图像ping：</h5><p>图像ping是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串的形式发送的，而相应可以是任意内容，但通常是像素图或204相应（No Content）。 图像ping有两个主要缺点：首先就是只能发送get请求，其次就是无法访问服务器的响应文本。</p>
<h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"done!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">"https://raw.githubusercontent.com/zhangmengxue/Todo-List/master/me.jpg"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(img,<span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>

<p>然后页面上就可以显示我放在我的github上某个地方的照片啦。</p>
<p>与<img>类似的可以跨域内嵌资源的还有:</p>
<p>(1)<script src></script>标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。上面jsonp也用到了呢。</p>
<p>(2) <link src>标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。</p>
<p>(3)<video> 和 <audio>嵌入多媒体资源。</audio></video></p>
<p>(4)<object>, <embed> 和 <applet>的插件。</applet></object></p>
<p>(5)@font-face引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</p>
<p>(6) <frame> 和 <iframe>载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</iframe></p>
<h5 id="8-使用片段识别符来进行跨域"><a href="#8-使用片段识别符来进行跨域" class="headerlink" title="8.使用片段识别符来进行跨域"></a>8.使用片段识别符来进行跨域</h5><p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<a href="http://example.com/x.html#flag的#flag。如果只是改变片段标识符，页面不会重新刷新。" target="_blank" rel="noopener">http://example.com/x.html#flag的#flag。如果只是改变片段标识符，页面不会重新刷新。</a><br>父窗口可以把信息，写入子窗口的片段标识符。在父窗口写入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>).onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> src = <span class="string">"http://127.0.0.1/JSONP/b.html"</span> + <span class="string">'#'</span> + <span class="string">"data"</span>;</span><br><span class="line">    <span class="keyword">this</span>.src = src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="子窗口通过监听hashchange事件得到通知。"><a href="#子窗口通过监听hashchange事件得到通知。" class="headerlink" title="子窗口通过监听hashchange事件得到通知。"></a>子窗口通过监听hashchange事件得到通知。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b.html加载完成"</span>)</span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">        <span class="built_in">console</span>.log(message)<span class="comment">//#data</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="同样的，子窗口也可以改变父窗口的片段标识符。"><a href="#同样的，子窗口也可以改变父窗口的片段标识符。" class="headerlink" title="同样的，子窗口也可以改变父窗口的片段标识符。"></a>同样的，子窗口也可以改变父窗口的片段标识符。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href= target + <span class="string">"#"</span> + hash;</span><br></pre></td></tr></table></figure>

</body>
            <hr>
          </div>
          <br>
          <div>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
                <a class="hover-with-bg" href="/tags/javascript%E8%B7%A8%E5%9F%9F">javascript跨域</a>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>

  <script src="/js/lazyload.js" ></script>


  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>


  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "js中的跨域及其解决的办法&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "left",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script>
    if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) || (/Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent))) {
      $("#background").css("background-attachment", "scroll");
    }
  </script>

</body>
</html>
