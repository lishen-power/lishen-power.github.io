<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>面试题2019.12.06 ~ Hexo</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
  
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">

  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >
  
  <link rel="stylesheet" href="/css/main.css"  >

  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hexo</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">主页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">档案</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类目录</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p class="mt-3">Friday, January 3rd 2020, 9:40 pm</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <p>1.http请求：指从客户端到服务器端的请求消息指从客户端到服务器端的请求消息,</p>
<p>HTTP请求是指从客户端到服务器端的请求消息，包括消息首行中，对资源的请求方法、资源的标识符及使用的协议。如果HTTP/1.0服务器收到简单请求，它必须回应一个HTTP/0.9格式的简单回应。HTTP请求是指从客户端到服务器端的请求消息，包括消息首行中，对资源的请求方法、资源的标识符及使用的协议。如果HTTP/1.0服务器收到简单请求，它必须回应一个HTTP/0.9格式的简单回应。</p>
<p>2 http 请求方式</p>
<p>1.Get和Post请求的区别</p>
<p>get请求的内容是显示在地址上，例如RegisterDao.jsp?key1=value1&amp;key2=value2，而post请求的内容不显示在地址上，是在消息正文中发送的，因此，get请求没有post请求安全；</p>
<p>get请求通常用来获取数据，例如查列表、查详情等诸如筛选之类的查询操作，post请求通常用来新增数据；</p>
<p>get和post请求是有长度限制的，但是实际上并不是请求限制，http协议并未规定get和post的长度限制，而是不同浏览器或web服务器对URL的长度进行了不同的限制，如果超出了最大长度，大部分的服务器直接截断，也有一些服务器会报414错误；</p>
<p>get请求比post请求效率高；</p>
<p>get请求只能发送ASCII字符，而post能发送更多的数据类型；</p>
<p>为什么Get请求比Post请求效率更高？</p>
<p>1.请求包含的字段不同</p>
<p>post请求需要在请求的body部分包含数据，所以会多了几个数据描述部分的字段（如：content-type）。</p>
<p>2.post请求和get请求的过程是不同的</p>
<p>post请求的过程是这样的：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回100 Continue响应<br>（5）浏览器发送数据<br>（6）服务器返回200 OK响应<br> get请求的过程是这样的：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送get请求头和数据（第三次握手，http会在此时进行数据发送）<br>（4）服务器返回200 OK响应<br>从请求过程就能够看出，post请求在第三次握手中仅发送了请求头，待服务器返回响应后才进行真正意义上的发送数据，这样就比get请求多了一次响应和发送数据的过程，自然而然，执行效率也就没有get请求高。<br>3.get请求对静态资源进行缓存<br>在发送一次请求后，get请求会将数据缓存起来，而post请求不会，也就是说如果使用ajax以get的请求方式执行两次请求，第一次请求会将静态资源（html页面、图片等）进行缓存，第二次get请求直接从缓存中获取这些静态资源。<br>4.post请求不能进行管道化传输<br>HTTP的第一次会话需要先建立tcp连接，然后才能通信，但是如果每次都只进行一次http会话，那么这次会话就占用了请求的资源。于是出现了持久连接：在http/1.0+中是connection首部中添加keep-alive值，在http/1.1中是在connection首部中添加persistent值，当然两者不仅仅是命名上的差别，http/1.1中，持久连接是默认的，除非显示在connection中添加close，否则持久连接不会关闭，而http/1.0+中则恰好相反，除非显示在connection首部中添加keep-alive，否则在接收数据包后连接就断开了。<br>持久连接还不能完全满足需求，在http/1.1中，还有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，虽然这样提升了传输速度，但是还有一个问题：不安全。如果一个管道中有10个连接，在发送出9个后，突然服务器告诉你，连接关闭了，此时客户端即使收到了前9个请求的答复，也会将这9个请求的内容清空，也就是说，如果需要重新发送连接，此时，客户端的这9个请求需要重新发送。这种情况对于幂等请求是没有影响的，如果是post这样的非幂等请求（比如前两天微信支付的问题，支付了N多次，老板就是收不到钱），这样肯定是行不通的。1.Get和Post请求的区别</p>
<p>get请求的内容是显示在地址上，例如RegisterDao.jsp?key1=value1&amp;key2=value2，而post请求的内容不显示在地址上，是在消息正文中发送的，因此，get请求没有post请求安全；</p>
<p>get请求通常用来获取数据，例如查列表、查详情等诸如筛选之类的查询操作，post请求通常用来新增数据；</p>
<p>get和post请求是有长度限制的，但是实际上并不是请求限制，http协议并未规定get和post的长度限制，而是不同浏览器或web服务器对URL的长度进行了不同的限制，如果超出了最大长度，大部分的服务器直接截断，也有一些服务器会报414错误；</p>
<p>get请求比post请求效率高；</p>
<p>get请求只能发送ASCII字符，而post能发送更多的数据类型；</p>
<p>为什么Get请求比Post请求效率更高？</p>
<p>1.请求包含的字段不同</p>
<p>post请求需要在请求的body部分包含数据，所以会多了几个数据描述部分的字段（如：content-type）。</p>
<p>2.post请求和get请求的过程是不同的</p>
<p>post请求的过程是这样的：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回100 Continue响应<br>（5）浏览器发送数据<br>（6）服务器返回200 OK响应<br> get请求的过程是这样的：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送get请求头和数据（第三次握手，http会在此时进行数据发送）<br>（4）服务器返回200 OK响应<br>从请求过程就能够看出，post请求在第三次握手中仅发送了请求头，待服务器返回响应后才进行真正意义上的发送数据，这样就比get请求多了一次响应和发送数据的过程，自然而然，执行效率也就没有get请求高。<br>3.get请求对静态资源进行缓存<br>在发送一次请求后，get请求会将数据缓存起来，而post请求不会，也就是说如果使用ajax以get的请求方式执行两次请求，第一次请求会将静态资源（html页面、图片等）进行缓存，第二次get请求直接从缓存中获取这些静态资源。<br>4.post请求不能进行管道化传输<br>HTTP的第一次会话需要先建立tcp连接，然后才能通信，但是如果每次都只进行一次http会话，那么这次会话就占用了请求的资源。于是出现了持久连接：在http/1.0+中是connection首部中添加keep-alive值，在http/1.1中是在connection首部中添加persistent值，当然两者不仅仅是命名上的差别，http/1.1中，持久连接是默认的，除非显示在connection中添加close，否则持久连接不会关闭，而http/1.0+中则恰好相反，除非显示在connection首部中添加keep-alive，否则在接收数据包后连接就断开了。<br>持久连接还不能完全满足需求，在http/1.1中，还有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，虽然这样提升了传输速度，但是还有一个问题：不安全。如果一个管道中有10个连接，在发送出9个后，突然服务器告诉你，连接关闭了，此时客户端即使收到了前9个请求的答复，也会将这9个请求的内容清空，也就是说，如果需要重新发送连接，此时，客户端的这9个请求需要重新发送。这种情况对于幂等请求是没有影响的，如果是post这样的非幂等请求（比如前两天微信支付的问题，支付了N多次，老板就是收不到钱），这样肯定是行不通的。</p>
<p>3 最常用的http状态码</p>
<p>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。我们在开发过程中比较常见的状态码有：200(请求成功)、301(页面重定向)、404(未找到对应的资源文件)、500(服务器错误)。HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。我们在开发过程中比较常见的状态码有：200(请求成功)、301(页面重定向)、404(未找到对应的资源文件)、500(服务器错误)。  </p>
<p>4.http和https的概念</p>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>5.http和https的区别</p>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>6.let 和var， 区别</p>
<p>第一点，var在javascript中是支持预解析的，而let不支持预解析，一点，var在javascript中是支持预解析的，而let不支持预解析，</p>
<p>第二点：var可以重复定义同一个变量，但是let不可以，看代码：第二点：var可以重复定义同一个变量，但是let不可以</p>
<p>第三点：let可以形成块级作用域，在es6之前javascript只有函数作用域，没有块级作用域。</p>
<p>7.let .const区别</p>
<p>let声明的变量可以改变，值和类型都可以改变，没有限制。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>8.什么是闭包</p>
<p>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点： 1.作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 2.一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 简单的说， javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。</p>
<p>9.js判断一个对象属于哪一类</p>
<p>typeof、constructor、instanceof  typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是”object”。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。    instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。    constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。    Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。  </p>
<p>10.什么是跨域，说出跨域的方法</p>
<p>什么是跨域  跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。    跨域的访问会带来许多安全性的问题，比如，cookie 一般用于状态控制，常用于存储登录的信息，如果允许跨域访问，那么别的网站只需要一段脚本就可以获取你的 cookie，从而冒充你的身份去登录网站，造成非常大的安全问题，因此，现代浏览器均推行同源策略。  跨域解决方案  通过 jsonp 跨域 document.domain + iframe 跨域 location.hash + iframe window.name + iframe 跨域 postMessage 跨域 跨域资源共享（CORS） nginx 代理跨域 nodejs 中间件代理跨域 WebSocket 协议跨域 什么是同源策略？  同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。  </p>
<p>11.函数节流防抖</p>
<p>函数节流：一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。<br>有个需要频繁触发函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效。函数节流：一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。<br>有个需要频繁触发函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效。</p>
<p>防抖函数：一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。防抖函数：一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。</p>
<p>12.flex布局和传统布局有什么区别</p>
<p><strong>Flex布局，可以简便、完整、响应式地实现各种页面布-Flex布局，可以简便、完整、响应式地实现各种页面布</strong></p>
<p>传统布局，基于盒模型，依赖 display属性 、position属性 、float属性。它对于那些特殊布局非常不方便，比如垂直居中 fiex弹性布局css3最喜欢的新属性之一，主要思想是给予容器控制内部元素高度和宽度的能力。弹性根据两个轴线可以控制内部元素的位置，不在依靠float，clear、vertical-align属性 而这些属性也在设置了fiex后失效。传统布局，基于盒模型，依赖 display属性 、position属性 、float属性。它对于那些特殊布局非常不方便，比如垂直居中 fiex弹性布局css3最喜欢的新属性之一，主要思想是给予容器控制内部元素高度和宽度的能力。弹性根据两个轴线可以控制内部元素的位置，不在依靠float，clear、vertical-align属性 而这些属性也在设置了fiex后失效。  </p>
<p>12.flex布局有缺点</p>
<p>flex的优点： 1.效果绚丽 2.在页面端可以实现复杂的逻辑，减少交互时候的网络流量。 3.有比较不错的ide，可以方便快速的开发。 flex的缺点： 1.flex程序员相对难找 2.flex首次加载较慢 3.需要安装flashplayer 4.修改后需要编译   div+css的优点： 1.开发人员多，容易找到人手； 2.直接修改无需编译； 3.美工人员支持良好，拥有既定的制作流程； div+css的缺点： 1.效果没有flex绚丽，做出同等绚丽的代价比flex大 2.Css布局多浏览器支持有些麻烦flex的优点： 1.效果绚丽 2.在页面端可以实现复杂的逻辑，减少交互时候的网络流量。 3.有比较不错的ide，可以方便快速的开发。 flex的缺点： 1.flex程序员相对难找 2.flex首次加载较慢 3.需要安装flashplayer 4.修改后需要编译   div+css的优点： 1.开发人员多，容易找到人手； 2.直接修改无需编译； 3.美工人员支持良好，拥有既定的制作流程； div+css的缺点： 1.效果没有flex绚丽，做出同等绚丽的代价比flex大 2.Css布局多浏览器支持有些麻烦  </p>
<p>13前端优化</p>
<p>  1.精灵图<br>      最基本的是尽可能的将背景图片做成精灵图，减少图片的请求，所以一般web工程师的另一项基础本能就是精灵图的制作。<br>    2.css选择器优化<br>        在css中要尽量的使用子代选择器&gt;,少使用后代选择器，使用后代选择器时，搜素引擎会将所有的后代元素都进行搜索，如果我们使用子代选择器时，可以将搜索的范围缩小，从而减少搜索引擎的性能消耗。<br>    3.js改变样式直接操作类名<br>       js操作元素样式时,不要用style去直接添加样式，一般属性少时不会影响多少性能，其实则不然，在每次添加样式时，页面都会重绘一次，重绘是不得不重视的，操作样式时，直接操作类名，只引起一次重绘，用style直接添加样式会引起多次的重绘。<br>    4.js直接操作dom节点<br>      当操作节点时尽量将节点添加在元素的后面，如果插入到节点的前面时，会使插入节点之后的节点都引起回流，而插入到后面时只需要被插入的节点回流一次就可以了。<br>    可能有人不理解重绘与回流的概念<br>    5.正则匹配选择器<br>       在css3以及jQuery中的属性选择器，这些选择器中有的是用正则进行匹配的尽量不要去使用，当然如果对于性能优化不进行考虑的话，这些方法还是比较好用的，正则匹配选择器会使搜索引擎搜索所有的标签，很大的影响性能<br>    6.js获取元素优化<br>      在js中获得元素时，正常是使用document.getElementsById，搜索引擎会从Dom树的最底端，进行搜索，直到搜索到window中的document再进行返回搜索，所以在获得元素时最好是将document.body进行储存，当再次使用时，只需将这个变量取出使用，可以节省搜索引擎的性能<br>    7.内存溢出<br>     一般在递归运行时，会产生内存溢出，造成在运行递归时性能大幅度下降，在运行结束后内存会被系统回收，所以在运行递归时需要用对象将值保存，在每次递归运算时检测，如果存在则直接返回，不存在则添加，这样就可以解决递归的很大性能。<br>    8.对Ajax用GET请求<br>    POST请求是通过先发送HTTP请求头，再发送数据来实现的，GET而是没有请求头的，但是需要注意：GET大小限制约4K，POST则没有限制。<br>    9.延迟加载图片<br>        在页面发起请求时，请求量过大，可以使图片进行懒加载，当页面滚到到图片的位置时，再进行加载图片。</p>
<p>14.原型链和作用域链</p>
<p>作用域链</p>
<p>作用域是针对变量的，比如我们创建了一个函数a，函数A里面又包含了一个函数b，那么现在就有三个作用域：<br>全局作用域==&gt;函数a作用域==&gt;函数b作用域<br>作用域的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找。<br>如：</p>
<p>var num = 1;<br>function a(){<br>    var num = 2;<br>    function b(){<br>        var num = 3;<br>        console.log(num); // 3<br>    }<br>    b();<br>}<br>a();<br>最后打印出来的结果是3，因为执行函数b()的时候它在自己的范围内找到了变量num所以就不会往上继续查找，如果在函数b()中没有找到则会继续向上找，一直会找到全局变量num，这个查找的过程就叫作用域链。</p>
<p>函数b为什么可以在函数a中查找变量num，因为函数b是在函数a中创建的，也就是说函数b的作用域包括了函数a的作用域，当然也包括全局作用域，但是函数a不能向函数b中查找变量，因为作用域只会向上查找。<br>原型链</p>
<p>原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的对象就会继承创建出来的那个函数的属性，然后如果我访问new出来的这个对象的某个属性，但是我并没有在这个new出来的对象中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。<br>Object ==&gt; 构造函数1 ==&gt; 构造函数2<br>类似于css中的继承，如果自身没有定义就会继承父元素的样式。</p>
<p>function Person(){};<br>Person.prototype.name = “追梦子”;<br>var person1 = new Person();<br>console.log(person1.name); //追梦子</p>

            <hr>
          </div>
          <br>
          <div>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>

  <script src="/js/lazyload.js" ></script>


  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>


  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "面试题2019.12.06&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script>
    if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) || (/Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent))) {
      $("#background").css("background-attachment", "scroll");
    }
  </script>

</body>
</html>
